import random
import sys
import numpy as np
from string import ascii_lowercase

import utils
import atom
from action import Action

import itertools
import logging
from math import ceil

class PlanningTask(object):
    def __init__(self, num_atoms, num_variables, num_goal_variables, max_num_prevails, max_num_effects, max_atoms_per_layer, cg, opts):
        #causal_graph.print_causal_graph(cg)
        if (num_atoms < num_variables * 2 ):
            logging.error("There should be at least 2 values per variable")
            sys.exit(1)

        # num_goal_variables is the number of non-leaf goal variables
        self.leaf_variables = set([var for var in range(num_variables) if cg.is_leaf(var)])

        if (num_goal_variables + len(self.leaf_variables) > num_variables):
            logging.error("The number of goal variables cannot be larger than the total number of variables")
            logging.error("Non-leaf goal variables: %s, leaf variables: %s, number of variables: %s" % (num_goal_variables, len(self.leaf_variables), num_variables))
            sys.exit(1)

        if (max_atoms_per_layer > int(ceil(num_atoms/5))):
            logging.error("The number of atoms per layer should not be too large")
            sys.exit(1)

        self.seed = 0
        self.exactly_one_of_mutex_probability = 0.1
        self.enforce_new_atom_probability = 0.1
        self.enforce_new_atom_no_edge_probability = 0.01
        self.non_contributing_actions_add_probability = 0.1
        self.unconditioned_eff_probability = 0.1

        self.max_prevail_size = max_num_prevails
        self.max_effect_size = max_num_effects
        self.max_atoms_per_layer = max_atoms_per_layer

        if opts:
            self.seed = opts.seed
            self.exactly_one_of_mutex_probability = opts.exactly_one_of_mutex_probability
            self.enforce_new_atom_probability = opts.enforce_new_atom_probability
            self.enforce_new_atom_no_edge_probability = opts.enforce_new_atom_no_edge_probability
            self.non_contributing_actions_add_probability = opts.non_contributing_actions_add_probability
            self.unconditioned_eff_probability = opts.unconditioned_eff_probability

        cg_name = cg.method+"-"+str(cg.edge_probability)+"-cgseed"+str(cg.seed)
        self.problem_name = "%s-%s-%s-%s-%s-%s-%s-seed%s" % (cg.method, num_atoms, num_variables, num_goal_variables, max_num_prevails, max_num_effects, max_atoms_per_layer, self.seed)
        self.domain_name =  "autogenerated-"+cg_name+"-"+ "".join(random.choice(ascii_lowercase) for i in range(10))
        self.problem_file_name = "problem-%s-%s-%s-%s-%s-%s-seed%s.pddl" % (num_atoms, num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)
        self.domain_file_name = "domain-%s-%s-%s-%s-%s-%s-seed%s.pddl" % (num_atoms, num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)
        self.sas_file_name = "output-%s-%s-%s-%s-%s-%s-seed%s.sas" % (num_atoms, num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)

        self.debug_level = 0
        self.atoms = list(range(1, num_atoms+1))
        self.num_variables = num_variables
        self.set_variable_domains()
        self.set_initial_state()
        self.atoms_by_layer = []
        
        self.actions = []
        self.causal_graph = cg
        self.num_unmarked_edges = 0
        self.marked_edges = {}        
        for from_var in self.causal_graph.graph:
            self.num_unmarked_edges += len(self.causal_graph.graph[from_var])
            self.marked_edges[from_var] = set()                
        
        np.random.seed(self.seed)
        random.seed(self.seed)
        self.print_statement("Using seed %s" % self.seed, debug_level=1)
        self.print_statement("Number of unmarked edges in the causal graph: %s" % self.num_unmarked_edges, debug_level=1) 
        self.current_layer_set = self.initial_state.copy()
        self.last_achieved_atoms_set = self.initial_state.copy()
        self.last_deleted_atoms_set = set()
        self.last_deleted_variables_set = set()
        self.atoms_by_layer.append(self.last_achieved_atoms_set)
        self.print_statement("Starting with the initial layer of size %s" %  len(self.current_layer_set), debug_level=1)
        while len(self.current_layer_set) < len(self.atoms):
            self.get_next_layer()
            self.print_statement("Number of new achieved atoms: %s (current %s) out of %s" % (len(self.current_layer_set), len(self.last_achieved_atoms_set), len(self.atoms)), debug_level=1)
            self.print_statement("Number of deleted atoms in layer: %s" % len(self.last_deleted_atoms_set), debug_level=1)

        assert(self.num_unmarked_edges == 0)
        # Choosing the goal
        self.choose_goal(num_goal_variables)

    def choose_goal(self, num_goal_variables):
        ## Trying to get atoms from the last layer
        ## Making sure the goal does not include the none-of-those values
        self.goal_state = []
        actual_last_achieved_atoms_set = self.get_actual_last_achieved_atoms_set()
        assert(len(actual_last_achieved_atoms_set) > 0)
        # Getting all the atoms from the last layer that belong to the leaf variable
        last_layer_leafs = set([a for a in actual_last_achieved_atoms_set if self.get_variable(a) in self.leaf_variables])

        if len(last_layer_leafs) == 0 and num_goal_variables == 0:
            # No non-leaf goals and leafs do not appear in the last layer, choosing randomly for all
            self.goal_state = [self.get_actual_atom_random_non_init_value(var) for var in self.leaf_variables]
        else:
            # Getting at least one atom from the goal layer, giving preference to leafs
            if len(last_layer_leafs) > 0:
                # Values for leafs
                first_goal = self.get_random_sample(last_layer_leafs, 1)[0]
                self.goal_state.append(first_goal)
                first_goal_variable = self.get_variable(first_goal)
                all_but_first_goal = self.leaf_variables.copy() - set([first_goal_variable])
                for var in all_but_first_goal:
                    self.goal_state.append(self.get_actual_atom_random_non_init_value(var))
                # Values for non-leafs
                goal_vars_non_leafs = self.get_random_sample(set(range(self.num_variables)) - self.leaf_variables, num_goal_variables)
                self.goal_state.extend([self.get_actual_atom_random_value(var) for var in goal_vars_non_leafs])
            else:
                # Values for non-leafs
                last_layer_non_leafs = actual_last_achieved_atoms_set - last_layer_leafs
                first_goal = self.get_random_sample(last_layer_non_leafs, 1)[0]
                self.goal_state.append(first_goal)
                first_goal_variable = self.get_variable(first_goal)
                goal_vars_non_leafs_candidates = (set(range(self.num_variables)) - self.leaf_variables ) - set([first_goal_variable])
                goal_vars_non_leafs = self.get_random_sample(goal_vars_non_leafs_candidates, num_goal_variables-1)
                for var in goal_vars_non_leafs:
                    self.goal_state.append(self.get_actual_atom_random_value(var))

                # Values for leafs
                self.goal_state.extend([self.get_actual_atom_random_non_init_value(var) for var in self.leaf_variables])
        # Sorting the goal values
        self.goal_state.sort()


    def get_actual_last_achieved_atoms_set(self):
        for layer in self.atoms_by_layer[::-1]:
            actual_last_achieved_atoms_set = layer - self.atoms_none_of_those
            if len(actual_last_achieved_atoms_set) > 0:
                return actual_last_achieved_atoms_set        
        return set()

    def get_random_sample(self, from_set, size):
        return random.sample(from_set, size)

    def get_random_int(self, a, b):
        return random.randint(a, b)

    def uniform_zero_one(self, prob):
        return np.random.choice([0,1], p=[1-prob, prob]) == 1

    def enforce_new_atom(self):
        return self.uniform_zero_one(self.enforce_new_atom_probability)

    def enforce_new_atom_no_edge(self):
        return self.uniform_zero_one(self.enforce_new_atom_no_edge_probability)

    def add_non_contributing_action(self):
        return self.uniform_zero_one(self.non_contributing_actions_add_probability)

    def set_exactly_one_of_mutex(self):
        return self.uniform_zero_one(self.exactly_one_of_mutex_probability)

    def print_statement(self, _str, debug_level=1):
        if self.debug_level >= debug_level:
            logging.info(_str)

    def set_variable_domains(self):
        ## We start from 2 values in each domain and then we add a value to a domain, until there are no values left
        self.variable_domains = [2] * self.num_variables
        self.variable_extra_none_of_those_value = [False] * self.num_variables

        num_atoms_to_partition = len(self.atoms) - 2*self.num_variables
        while num_atoms_to_partition > 0:
            var = self.get_random_int(0, self.num_variables-1)
            self.variable_domains[var] += 1
            num_atoms_to_partition -= 1

        ## Choosing randomly the variables to add the non-of-those value
        for var in range(self.num_variables):
            if not self.set_exactly_one_of_mutex():
                self.variable_extra_none_of_those_value[var] = True
                self.variable_domains[var] += 1
                self.atoms.append(len(self.atoms)+1)

        ## Once all values are in, create another array with indexes of previous values
        self.value_indexes = [0] * self.num_variables
        for i in range(1, self.num_variables):
            self.value_indexes[i] = self.value_indexes[i-1] + self.variable_domains[i-1]
            
        self.atoms_to_variables = {}
        self.atoms_none_of_those = set()
        for var in range(self.num_variables):
            domain_values = self.get_values(var)
            for atom in domain_values:
                self.atoms_to_variables[atom] = var
            if self.variable_extra_none_of_those_value[var]:
                ## The last value is the none-of-those
                none_of_those_value = max(domain_values)
                self.atoms_none_of_those.add(none_of_those_value)

    def set_initial_state(self):
        self.initial_state = set()
        for var in range(self.num_variables):
            self.initial_state.add(self.value_indexes[var] + 1)
        
    def get_values(self, var):        
        return set(range(self.value_indexes[var] + 1, self.value_indexes[var] + 1 + self.variable_domains[var]))

    def get_values_not_covered(self, var):
        return (self.get_values(var) - self.current_layer_set) - self.new_achieved_atoms_in_layer

    def has_values_not_covered(self, var):
        return len(self.get_values_not_covered(var)) > 0


    def get_actual_atom_random_value(self, var):
        ## Assuming the none-of-those are the last values in the domain
        ## the range of values is between self.value_indexes[var] + 1 and self.value_indexes[var] + self.variable_domains[var] -1
        dom_size = self.variable_domains[var]
        if self.variable_extra_none_of_those_value[var]:
            dom_size -= 1
        return self.get_random_int(0, dom_size-1) + self.value_indexes[var] + 1  


    def get_actual_atom_random_non_init_value(self, var):
        ## Same as the function get_actual_atom_random_value, just skipping the first value, which is the initial value
        dom_size = self.variable_domains[var]
        if self.variable_extra_none_of_those_value[var]:
            dom_size -= 1
        return self.get_random_int(1, dom_size-1) + self.value_indexes[var] + 1  


    def get_random_value(self, var):
        ## the range of values is between self.value_indexes[var] + 1 and self.value_indexes[var] + self.variable_domains[var]
        dom_size = self.variable_domains[var]
        return self.get_random_int(0, dom_size-1) + self.value_indexes[var] + 1  

    def get_random_value_except(self, atom):
        ## the range of values is between self.value_indexes[var] + 1 and self.value_indexes[var] + self.variable_domains[var]
        var = self.get_variable(atom)
        values = self.get_values(var)
        values.remove(atom)
        return self.get_random_sample(values,1)[0]
         
    def get_variable(self, atom):
        return self.atoms_to_variables[atom]

    def get_variables_from_atoms(self, atoms):
        return set( [ self.get_variable(atom) for atom in atoms ] )

    def actions_to_string_pddl(self):
        return " ".join([ op.get_pddl(self.atoms_none_of_those) for op in self.actions ]) 

    def create_sas_plus_style_action(self, precondition, add_effect, delete_effect):
        return Action(precondition, add_effect, delete_effect)

    def check_edge_exists_in_causal_graph(self, variable_from, variable_to):
        if (variable_from == variable_to):
            return True
        return (variable_from in self.causal_graph.graph.keys() and variable_to in self.causal_graph.graph[variable_from])

    def mark_edge_in_causal_graph(self, variable_from, variable_to):
        # Modified to receive variables instead of atoms
        if not self.is_edge_in_causal_graph_marked(variable_from, variable_to):
            self.marked_edges[variable_from].add(variable_to)
            self.num_unmarked_edges -= 1

    def is_edge_in_causal_graph_marked(self, variable_from, variable_to):
        return (variable_from == variable_to) or variable_to in self.marked_edges[variable_from]

    def is_all_edges_causal_graph_marked_for_action(self, pre_vars, eff_vars):
        for pre, eff in itertools.product(pre_vars, eff_vars):
            if not self.is_edge_in_causal_graph_marked(pre, eff):
                return False
        return True

    def choose_unmarked_edge_from_causal_graph(self):
        # Assumption: run in the last layer
        for var in self.causal_graph.graph:
            if len(self.marked_edges[var]) == len(self.causal_graph.graph[var]):
                continue
            unmarked = self.causal_graph.graph[var] - self.marked_edges[var]
            assert(len(unmarked)>0)
            to_var = self.get_random_sample(unmarked, 1)[0]
            return var, to_var
        self.print_statement("All edges are covered!!!", debug_level=1)
        return None, None
    

    def check_action_with_causal_graph(self, pre_vars, eff_vars):
        for pre, eff in itertools.product(pre_vars, eff_vars):
            if not self.check_edge_exists_in_causal_graph(pre, eff):
                return False
        return True


    def mark_causal_graph_edge_by_action(self, pre_vars, eff_vars):        
        for pre, eff in itertools.product(pre_vars, eff_vars):
            self.mark_edge_in_causal_graph(pre, eff)

    def get_current_layer_not_covered_variables(self):
        vars_count = {}
        for atom in self.current_layer_set | self.new_achieved_atoms_in_layer:
            var = self.get_variable(atom)
            vars_count[var] = vars_count.get(var, 0) + 1

        return set([var for var in vars_count if vars_count[var] < self.variable_domains[var] ])

    def get_next_action_size(self):
        max_del_size = self.max_effect_size
        if self.causal_graph.max_effect:
            max_del_size = min(self.max_effect_size, self.causal_graph.max_effect)
        del_size = self.get_random_int(1, max_del_size)
        prevailsize = self.get_random_int(0, self.max_prevail_size)
        precondition_size = min(prevailsize + del_size, self.num_variables)
        if self.causal_graph.max_precondition:
            precondition_size = min(precondition_size, self.causal_graph.max_precondition)

        self.print_statement("Precondition size : %s, prevail size: %s, delete size: %s" % (precondition_size, prevailsize, del_size), debug_level=2)
        return precondition_size, del_size

    def get_single_precondition_from_set(self, from_set):
        pre = self.get_random_sample(from_set, 1)[0]
        pre_var = self.get_variable(pre)
        return pre, pre_var

    def get_next_action_pre(self, precondition_size, enforce_new_atom=True, pre_from_deleted=0):
        ## pre_from_deleted specifies the number of preconditions to take from the deleted in the last layer list.
        ## The actual amount depends on the number of variables in the deleted set.
        ## In any case it cannot be larger than the precondition size - 1 (the atom achieved in the last layer cannot be in the deleted set)

        assert(precondition_size > 0)
        enforced = not enforce_new_atom
        precondition = []
        variables_for_pre = set()
        values_for_pre = self.current_layer_set.copy()
        # At least one precondition should be from the last layer
        first_pre, first_pre_var = self.get_single_precondition_from_set(self.last_achieved_atoms_set)
        if not enforced and self.has_values_not_covered(first_pre_var):
            enforced = True
        precondition.append(first_pre)
        variables_for_pre.add(first_pre_var)
        values_for_pre -= self.get_values(first_pre_var)

        # getting pre from deleted
        deleted_vars = set()
        for atom in self.last_deleted_atoms_set:
            deleted_vars.add(self.get_variable(atom))
        deleted_vars -= variables_for_pre
        actual_pre_from_deleted = min(pre_from_deleted, len(deleted_vars), precondition_size - 1)
        deleted_values_for_pre = self.last_deleted_atoms_set.copy()
        deleted_values_for_pre -= self.get_values(first_pre_var)

        while (len(precondition) <= actual_pre_from_deleted) and len(deleted_values_for_pre) > 0:
            pre, pre_var = self.get_single_precondition_from_set(deleted_values_for_pre)
            assert(pre_var not in variables_for_pre)
            if not enforced and self.has_values_not_covered(pre_var):
                enforced = True

            ## Adding the value
            variables_for_pre.add(pre_var)
            precondition.append(pre)
            values_for_pre -= self.get_values(pre_var)
            deleted_values_for_pre -= self.get_values(pre_var)

        self.print_statement("Number of preconditions from deleted in the last layer: %s" % (len(precondition) - 1), debug_level=2)


        while (len(precondition) < precondition_size and len(values_for_pre) > 0) or not enforced:
            pre, pre_var = self.get_single_precondition_from_set(values_for_pre)
            assert(pre_var not in variables_for_pre)
            if not enforced and self.has_values_not_covered(pre_var):
                enforced = True
            ## Adding the value
            variables_for_pre.add(pre_var)
            precondition.append(pre)
            values_for_pre -= self.get_values(pre_var)

        self.print_statement("Chosen pre: %s" % precondition, debug_level=2)
        return precondition
    
    def get_next_action(self, enforce_new_atom=True):
        ## The action guarantees to achieve a new atom only when enforce_new_atom is True
        ## The return statement consists of a pair of action and boolean, indicating whether a new atom was achieved

        precondition_size, del_size = self.get_next_action_size()
        pre_from_deleted = self.get_random_int(0, precondition_size-1)
        precondition = self.get_next_action_pre(precondition_size, enforce_new_atom=enforce_new_atom, pre_from_deleted=pre_from_deleted)
        if enforce_new_atom:
            ## Taking from precondition first one atom that is not fully covered
            pre_not_fully_covered = []
            for atom in precondition:
                not_covered = self.get_values_not_covered(self.get_variable(atom))
                self.print_statement("%s, %s" % (atom, not_covered), debug_level=2)
                if len(not_covered) > 0:
                    pre_not_fully_covered.append(atom)

            assert(len(pre_not_fully_covered)>0)
            delete_effect = self.get_random_sample(pre_not_fully_covered, 1)
            delete_effect.extend(self.get_random_sample(set(precondition) - set(delete_effect), del_size-1))
        else:
            delete_effect = self.get_random_sample(precondition, del_size)

        pre_vars = [self.get_variable(fact) for fact in precondition]
        eff_vars = [self.get_variable(fact) for fact in delete_effect]
        if not self.check_action_with_causal_graph(pre_vars, eff_vars):
            return None

        # Creating add effects from delete effects
        add_effect = set()        
        for i in range(len(delete_effect)):
            fact = delete_effect[i]
            val  = None
            if enforce_new_atom and i==0:
                not_covered = self.get_values_not_covered(self.get_variable(fact))
                val = self.get_random_sample(not_covered, 1)[0]
            else:
                val = self.get_random_value_except(fact)
            add_effect.add(val)
            self.print_statement("Added add effect " + str(val), debug_level=2)

        # Checking if the action adds anything new to the problem
        new_effects = add_effect - self.current_layer_set
        if len(new_effects) == 0 \
           and self.is_all_edges_causal_graph_marked_for_action(pre_vars, eff_vars) \
           and not self.add_non_contributing_action():
            return None

        self.mark_causal_graph_edge_by_action(pre_vars, eff_vars)
        self.new_achieved_atoms_in_layer.update(new_effects)
        self.new_deleted_atoms_in_layer.update(delete_effect)
        return self.create_sas_plus_style_action(precondition, add_effect, delete_effect)

    def get_random_action_for_edge(self, from_var, to_var):
        ## The action does not guarantee to achieve any new atom
        # Assumption: the edge chosen from the requested causal graph

        possible_prv = self.get_values(from_var) & self.current_layer_set
        possible_del = self.get_values(to_var) & self.current_layer_set
        assert(len(possible_prv) > 0)
        assert(len(possible_del) > 0)
        prec = self.get_random_sample(possible_prv, 1)
        delete_eff = self.get_random_sample(possible_del, 1)[0]
        prec.append(delete_eff)
        add_eff = self.get_random_value_except(delete_eff)
        add_effs = [add_eff]
        self.mark_edge_in_causal_graph(from_var, to_var)


        self.new_achieved_atoms_in_layer.add(add_eff)
        return self.create_sas_plus_style_action(prec, add_effs, [delete_eff])

    def get_random_action_no_edge(self):
        ## The action guarantees to achieve a new atom 
        vars = self.get_current_layer_not_covered_variables()
        assert(len(vars)>0)
        var = self.get_random_sample(vars, 1)[0]
        possible_del = self.get_values(var) & self.current_layer_set
        assert(len(possible_del) > 0)
        delete_eff = self.get_random_sample(possible_del, 1)       
        not_covered = self.get_values_not_covered(var)
        assert(len(not_covered)>0)
        add_eff = self.get_random_sample(not_covered, 1)[0]
        assert(add_eff not in self.current_layer_set)
        self.new_achieved_atoms_in_layer.add(add_eff)
        return self.create_sas_plus_style_action(delete_eff, [add_eff], delete_eff)


    def add_action(self, action):
        if action is None:
            return
        id = len(self.actions) + 1
        action.id = id
        self.actions.append(action)

    def get_next_layer_size(self):
        return min(self.get_random_int(1, self.max_atoms_per_layer), len(self.atoms) - len(self.current_layer_set))


    def get_next_layer(self):
        ## Getting the number of atoms for this layer, no more than what's currently missing
        ## If all atoms are covered (last layer), creating actions for marking the missing causal graph edges
        ## When a new atom was not achieved for a while, we speed up as follows:
        ##  1. we enforce an action to achieve a new atom (or fail) (using enforce_new_atom_probability)
        ##  2. we add an action that achieves a new atom and does not contribute any edges to the causal graph.
        ##      This is always possible, while there are unachieved atoms. We use enforce_new_atom_no_edge_probability
        ##  If both happen, we prefer the second one, since it is certain to add an atom. 

        num_atoms_for_layer = self.get_next_layer_size()
        self.new_achieved_atoms_in_layer = set()
        self.new_deleted_atoms_in_layer = set()
        while len(self.new_achieved_atoms_in_layer) < num_atoms_for_layer:
            enforce = self.enforce_new_atom()
            enforce_no_edge = self.enforce_new_atom_no_edge()
            #self.print_statement("Enforce: %s, enforced no edge %s" % (enforce, enforce_no_edge) )
            if enforce_no_edge:
                self.add_action(self.get_random_action_no_edge())
                continue
            action = self.get_next_action(enforce_new_atom=enforce)
            self.add_action(action)

        # Update the layer
        if len(self.new_achieved_atoms_in_layer) > 0:
            self.atoms_by_layer.append(self.new_achieved_atoms_in_layer)
            self.last_achieved_atoms_set = self.new_achieved_atoms_in_layer
            self.last_deleted_atoms_set = self.new_deleted_atoms_in_layer
            self.current_layer_set.update(self.new_achieved_atoms_in_layer)
            self.new_achieved_atoms_in_layer = set()

        if len(self.current_layer_set) == len(self.atoms):
            ## We have constructed the last layer
            while (self.num_unmarked_edges > 0):
                # Some edges are still not marked. Pick an unmarked edge, add an action for that edge
                var, to_var = self.choose_unmarked_edge_from_causal_graph()
                if var is None:
                    logging.error("Problem with generating task!")
                    exit(1)
                self.add_action(self.get_random_action_for_edge(var, to_var))


    def write_pddl(self, domain_file, problem_file):
        if domain_file is None:
            domain_file = self.domain_file_name
            problem_file = self.problem_file_name

        utils.create_missing_folder(domain_file)

        with open(domain_file, 'w') as outDomain:
            atoms_str = " ".join(atom.get_atoms_pddl(self.atoms, False))

            outDomain.write("(define (domain %s) \n (:requirements :strips) \n (:predicates " % self.domain_name + \
                                atoms_str + ")\n" + \
                                self.actions_to_string_pddl() + "\n)")
    
        utils.create_missing_folder(problem_file)
        with open(problem_file, 'w') as outProblem:
            init_str = " ".join(atom.get_atoms_pddl(self.initial_state, False))
            goal_str = " ".join(atom.get_atoms_pddl(self.goal_state, False))
            outProblem.write("(define (problem %s)\n(:domain %s) \n (:init \n " % (self.problem_name, self.domain_name) + \
                             init_str + ")\n" + \
                             "(:goal (and " + goal_str + ")\n ))" )



    def get_var_val_fdr(self, fact):
        var = self.get_variable(fact)
        val = fact - (self.value_indexes[var] + 1)  # offset
        assert(val >= 0 and val < self.variable_domains[var])
        return var, val


    def write_variables_fdr(self, stream):
        print(len(self.initial_state), file=stream)
        for var in range(self.num_variables):
            values = atom.get_atoms_fdr(self.get_values(var), False)
            rang = self.variable_domains[var]
            axiom_layer = -1
            print("begin_variable", file=stream)
            print("var%d" % var, file=stream)
            print(axiom_layer, file=stream)
            print(rang, file=stream)
            assert rang == len(values), (rang, values)
            for value in values:
                print(value, file=stream)
            print("end_variable", file=stream)        

    def write_init_state_fdr(self, stream):
        print("begin_state", file=stream)
        for var in range(self.num_variables):
            print(0, file=stream)     # the initial value is always 0 (WLOG)
        print("end_state", file=stream)

    def write_goal_fdr(self, stream):
        goal = [ self.get_var_val_fdr(fact) for fact in self.goal_state ]
        print("begin_goal", file=stream)
        print(len(goal), file=stream)
        for var, val in goal:
            print(var, val, file=stream)
        print("end_goal", file=stream)


    def write_fdr(self, filename="output.sas"):
        if filename is None:
            filename = self.sas_file_name
            
        utils.create_missing_folder(filename)
        with open(filename, 'w') as output_file:

            print("begin_version", file=output_file)
            print(3, file=output_file)
            print("end_version", file=output_file)
            print("begin_metric", file=output_file)
            print(0, file=output_file)
            print("end_metric", file=output_file)
            self.write_variables_fdr(output_file)

            print(0, file=output_file)  # No mutexes
            self.write_init_state_fdr(output_file)
            self.write_goal_fdr(output_file)

            print(len(self.actions), file=output_file)
            for op in self.actions:
                op.write_fdr(output_file, self.get_var_val_fdr)
            print(0, file=output_file)  # No axioms
