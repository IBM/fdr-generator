import random
import sys
import numpy as np
from string import ascii_lowercase

from planning_task import PlanningTask
from causal_graph import CausalGraphCustom
import json
import logging
from math import ceil

class PlanningTaskCustom(PlanningTask):
    def __init__(self, max_atoms_per_layer, opts):

        self.seed = 0
        self.exactly_one_of_mutex_probability = 0.1
        self.enforce_new_atom_probability = 0.1
        self.enforce_new_atom_no_edge_probability = 0.01
        self.non_contributing_actions_add_probability = 0.1
        self.unconditioned_eff_probability = 0.1

        if opts:
            self.seed = opts.seed
            self.exactly_one_of_mutex_probability = opts.exactly_one_of_mutex_probability
            self.enforce_new_atom_probability = opts.enforce_new_atom_probability
            self.enforce_new_atom_no_edge_probability = opts.enforce_new_atom_no_edge_probability
            self.non_contributing_actions_add_probability = opts.non_contributing_actions_add_probability
            self.unconditioned_eff_probability = opts.unconditioned_eff_probability

        # Getting info from the planning task
        task_info = {}
        with open(opts.input_json_file_name, "r") as f:
            task_info = json.load(f)

        self.num_variables = len(task_info["variables"])

        self.variable_domains = [ var["domain_size"] for var in task_info["variables"] ]
        self.variable_extra_none_of_those_value = [ var["none_of_those_value"] == 1 for var in task_info["variables"] ]


        num_atoms = sum(self.variable_domains)
        num_goal_variables = sum([ var["is_goal"] for var in task_info["variables"] ])
        cg = CausalGraphCustom(task_info, self.seed)
        #causal_graph.print_causal_graph(cg)

        self.max_prevail_size = task_info["max_num_prevails"]
        self.max_effect_size = task_info["max_num_effects"]
        if max_atoms_per_layer:
            self.max_atoms_per_layer = max_atoms_per_layer
        else:
            self.max_atoms_per_layer = min(int(num_atoms/10), 25)

        # num_goal_variables is the number of non-leaf goal variables
        self.leaf_variables = set([var for var in range(self.num_variables) if cg.is_leaf(var)])
        num_goal_variables -= len(self.leaf_variables)

        if (self.max_atoms_per_layer > int(ceil(num_atoms/5))):
            logging.error("The number of atoms per layer should not be too large: number of atoms is %s, average number of layers would be %s" % (num_atoms, int(num_atoms/self.max_atoms_per_layer)))
            sys.exit(1)

        random.seed(self.seed)
        np.random.seed(self.seed)
        cg_name = cg.method+"-"+str(cg.edge_probability)+"-cgseed"+str(cg.seed)
        self.problem_name = "%s-%s-%s-%s-%s-%s-%s-seed%s" % (cg.method, num_atoms, self.num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)
        self.domain_name =  "autogenerated-"+cg_name+"-"+ "".join(random.choice(ascii_lowercase) for i in range(10))
        self.problem_file_name = "problem-%s-%s-%s-%s-%s-%s-seed%s.pddl" % (num_atoms, self.num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)
        self.domain_file_name = "domain-%s-%s-%s-%s-%s-%s-seed%s.pddl" % (num_atoms, self.num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)
        self.sas_file_name = "output-%s-%s-%s-%s-%s-%s-seed%s.sas" % (num_atoms, self.num_variables, num_goal_variables, self.max_prevail_size, self.max_effect_size, self.max_atoms_per_layer, self.seed)

        self.debug_level = 0
        self.atoms = list(range(1, num_atoms+1))
        self.set_variable_domains_from_task()
        self.set_initial_state()
        self.atoms_by_layer = []
        
        self.actions = []
        self.causal_graph = cg
        self.num_unmarked_edges = 0
        self.marked_edges = {}        
        for from_var in self.causal_graph.graph:
            self.num_unmarked_edges += len(self.causal_graph.graph[from_var])
            self.marked_edges[from_var] = set()                
        

        self.print_statement("Using seed %s" % self.seed, debug_level=1)
        self.print_statement("Number of unmarked edges in the causal graph: %s" % self.num_unmarked_edges, debug_level=1) 
        self.current_layer_set = self.initial_state.copy()
        self.last_achieved_atoms_set = self.initial_state.copy()
        self.last_deleted_atoms_set = set()
        self.last_deleted_variables_set = set()
        self.atoms_by_layer.append(self.last_achieved_atoms_set)
        self.print_statement("Starting with the initial layer of size %s" %  len(self.current_layer_set), debug_level=1)
        while len(self.current_layer_set) < len(self.atoms):
            self.get_next_layer()
            self.print_statement("Number of new achieved atoms: %s (current %s) out of %s" % (len(self.current_layer_set), len(self.last_achieved_atoms_set), len(self.atoms)), debug_level=1)
            self.print_statement("Number of deleted atoms in layer: %s" % len(self.last_deleted_atoms_set), debug_level=1)

        assert(self.num_unmarked_edges == 0)
        # Choosing the goal
        self.choose_goal(num_goal_variables)

    def set_variable_domains_from_task(self):
        ## The values are created outside of this function
        ## Once all values are in, create another array with indexes of previous values
        self.value_indexes = [0] * self.num_variables
        for i in range(1, self.num_variables):
            self.value_indexes[i] = self.value_indexes[i-1] + self.variable_domains[i-1]
            
        self.atoms_to_variables = {}
        self.atoms_none_of_those = set()
        for var in range(self.num_variables):
            domain_values = self.get_values(var)
            for atom in domain_values:
                self.atoms_to_variables[atom] = var
            if self.variable_extra_none_of_those_value[var]:
                ## The last value is the none-of-those
                none_of_those_value = max(domain_values)
                self.atoms_none_of_those.add(none_of_those_value)